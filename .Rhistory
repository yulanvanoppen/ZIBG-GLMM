pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 1
pb
pb <- rep(0, nH)
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 1
pb
pb <- rep(0, nH)
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 1
pb
pb <- rep(0, nH)
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 1
pb
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- rlnorm(1, 0, 0.1)
pb
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- rlnorm(1, 0, 0.1)
pb
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 0.1 * sample(c(-1, 1), 1) * rlnorm(1, 0, 0.1)
pb
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 0.1 * sample(c(-1, 1), 1) * rlnorm(1, 0, 0.1)
pb
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 0.1 * sample(c(-1, 1), 1) * rlnorm(1, 0, 0.1)
pb
pb <- rep(0, nH)
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 0.1 * sample(c(-1, 1), 1) * rlnorm(1, 0, 0.1)
pb
pb <- rep(0, nH)
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 0.1 * sample(c(-1, 1), 1) * rlnorm(1, 0, 0.1)
pb
pb <- rep(0, nH)
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 0.1 * sample(c(-1, 1), 1) * rlnorm(1, 0, 0.1)
pb
pb <- rep(1, nH)
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/30) + rbinom(1, (len>13), len/30)
len_pb <- sample(2:4, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) - 1 + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) - 1 + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- 0.1 * sample(c(-1, 1), 1) * rlnorm(1, 0, 0.1)
pb
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
pb
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
pb
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
pb != 1
# CONVERT TO CANDLESTICKS -----------------------------------------------------------------------
OHCL       <- data.frame(hour = 1:nH)
OHCL$open  <- df$price[seq(1, nrow(df)-1, 1/dt)]
OHCL$high  <- apply(matrix(df$price[1:(nrow(df)-1)], 1/dt), 2, max)
OHCL$low   <- apply(matrix(df$price[1:(nrow(df)-1)], 1/dt), 2, min)
OHCL$close <- df$price[seq(1/dt, nrow(df), 1/dt)]
OHCL$pullback <- pb != 1
OHCL
library(plotly)
red   <- list(line = list(color = 'lightsalmon'))
green <- list(line = list(color = 'darkseagreen'))
fig <- OHCL %>% plot_ly(x = ~hour, type="candlestick",
open = ~open, close = ~close,
high = ~high, low = ~low,
increasing = green, decreasing = red,
name = "BTCUSDT")
fig <- fig %>% layout(title = "Basic Candlestick Chart",
xaxis = list(rangeslider = list(visible = F)),
yaxis = list(range = c(1000, 4000)))
ind <- which(OHCL$pullback)
blue <- list(line = list(color = 'dodgerblue'))
fig <- fig %>% add_trace(x = ~hour[ind], type="candlestick",
open = ~open[ind], close = ~close[ind],
high = ~high[ind], low = ~low[ind],
increasing = blue, decreasing = blue, opacity = 0.9,
name = "Pullback")
fig
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
?runif
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
# CONVERT TO CANDLESTICKS -----------------------------------------------------------------------
OHCL       <- data.frame(hour = 1:nH)
OHCL$open  <- df$price[seq(1, nrow(df)-1, 1/dt)]
OHCL$high  <- apply(matrix(df$price[1:(nrow(df)-1)], 1/dt), 2, max)
OHCL$low   <- apply(matrix(df$price[1:(nrow(df)-1)], 1/dt), 2, min)
OHCL$close <- df$price[seq(1/dt, nrow(df), 1/dt)]
OHCL$pullback <- pb != 1
library(plotly)
red   <- list(line = list(color = 'lightsalmon'))
green <- list(line = list(color = 'darkseagreen'))
fig <- OHCL[-100:0 + nH, ] %>% plot_ly(x = ~hour, type="candlestick",
open = ~open, close = ~close,
high = ~high, low = ~low,
increasing = green, decreasing = red,
name = "BTCUSDT")
fig <- fig %>% layout(title = "Basic Candlestick Chart",
xaxis = list(rangeslider = list(visible = F))
# , yaxis = list(range = c(1000, 4000))
)
ind <- which(OHCL$pullback)
blue <- list(line = list(color = 'dodgerblue'))
fig <- fig %>% add_trace(x = ~hour[ind], type="candlestick",
open = ~open[ind], close = ~close[ind],
high = ~high[ind], low = ~low[ind],
increasing = blue, decreasing = blue, opacity = 0.9,
name = "Pullback")
fig
# fig2 <- window  %>% plot_ly(x=~hour, y=~vol, type='bar', name = "Volume",
#           color = ~direction, colors = c(red$line$color, green$line$color))
# fig2 <- fig2 %>% layout(yaxis = list(title = "Volume"))
#
# fig <- subplot(fig, fig2, heights = c(0.7,0.2), nrows=2,
#              shareX = TRUE, titleY = TRUE)
#
# fig
fig <- OHCL[0:250, ] %>% plot_ly(x = ~hour, type="candlestick",
open = ~open, close = ~close,
high = ~high, low = ~low,
increasing = green, decreasing = red,
name = "BTCUSDT")
fig <- fig %>% layout(title = "Basic Candlestick Chart",
xaxis = list(rangeslider = list(visible = F))
# , yaxis = list(range = c(1000, 4000))
)
ind <- which(OHCL$pullback)
blue <- list(line = list(color = 'dodgerblue'))
fig <- fig %>% add_trace(x = ~hour[ind], type="candlestick",
open = ~open[ind], close = ~close[ind],
high = ~high[ind], low = ~low[ind],
increasing = blue, decreasing = blue, opacity = 0.9,
name = "Pullback")
fig
# fig2 <- window  %>% plot_ly(x=~hour, y=~vol, type='bar', name = "Volume",
#           color = ~direction, colors = c(red$line$color, green$line$color))
# fig2 <- fig2 %>% layout(yaxis = list(title = "Volume"))
#
# fig <- subplot(fig, fig2, heights = c(0.7,0.2), nrows=2,
#              shareX = TRUE, titleY = TRUE)
#
# fig
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/HFT/api/sim_data.R', echo=TRUE)
mu
# SIMULATE 'RAW' DATA ---------------------------------------------------------------------------
set.seed(0)
nH <- 1000
sigma <- 0.005
S0 <- 2000
dt <- 0.001
scale   <- 0.01
seglens <- 10:20
t_grid <- seq(0, nH, dt)
mu <- rep(0, nH)                            # implement trends causing varying mu and sigma
sigma <- rep(0.01, nH)
idx <- 1
segments <- idx
while (idx < nH) {
len <- sample(seglens, 1)
mu[idx:min(idx+len-1, nH)] <- sample(c(-1, rep(0, 3), 1), 1) * rlnorm(1, 0, 0.2)
sigma[idx:min(idx+len-1, nH)] <- (1 + 5 * mu[idx:min(idx+len-1, nH)] != 0) * sigma[idx:min(idx+len-1, nH)]
idx <- idx + len
segments <- c(segments, min(idx, nH))
}
mu <- scale * mu
pb <- rep(1, nH)
pullback <- function(seg, len) {
n_pb <- rbinom(1, (len>9), len/20) + rbinom(1, (len>13), len/20)
len_pb <- sample(3:5, n_pb, replace = T)
ind_pb <- NULL
if (n_pb == 1)
ind_pb <- seg + round((len-len_pb)/2) + 1:len_pb
if (n_pb == 2)
ind_pb <- c(seg + round((len-sum(len_pb))/3) - 1 + 1:len_pb[1],
seg + len_pb[1] + round(2*(len-sum(len_pb))/3) + 1:len_pb[2])
return(ind_pb)
}
for (idx in 1 : (length(segments)-1))
if (mu[segments[idx]] != 0)
pb[pullback(segments[idx], segments[idx+1] - segments[idx])] <- runif(1, -0.25, 0) * rlnorm(1, 0, 0.1)
gbm_sim <- function(t, mu, sigma, S0, dt) {
epsilon <- rnorm(t/dt)
moves <- rep(mu, each = 1/dt) * dt + sigma * epsilon * sqrt(dt)
gbm <- c(S0, rep(0, t/dt))
for (step in 1:(t/dt)) {
gbm[step+1] <- gbm[step] * (1 + moves[step])
}
return(gbm)
}
sim <- gbm_sim(nH, mu*pb, sigma*pb, S0, dt)
df <- data.frame(price = sim)
dir <- mu
dir
sign(0.5)
sign(-0.5)
sign(0)
sign(mu)
source('C:/Users/Yulan/Google Drive/_RUG/2019-2020 MSc Mathematics Year 2/Master Research Project/paper/code/map.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/_RUG/2019-2020 MSc Mathematics Year 2/Master Research Project/paper/code/map.R', echo=TRUE)
source('C:/Users/Yulan/Google Drive/_RUG/2019-2020 MSc Mathematics Year 2/Master Research Project/paper/code/map.R', echo=TRUE)
?getData
## plot regions with labels
par(mar = c(0,0,0,0))
plot(italy_red)
points(coord, pch = 20)
text(coord, pch = 20, labels = rownames(coord), font = 2)
?`plot,SpatialPolygons,missing-method`
?getData
italy[1:10]
italy[, 1:10]
italy
italy[1:10, ]
italy[c(1, 3, 5), ]
par(mar = c(0,0,0,0))
plot(italy_red[c(1, 3, 5), ])
points(coord, pch = 20)
text(coord, pch = 20, labels = rownames(coord), font = 2)
italy <- getData('GADM', country='NL', level=1) ## download map
italy_red <- gSimplify(italy, tol=0.001, topologyPreserve=TRUE) ## reduce definition of the map
## geographic coordinates (longitude and latitude)
coord <- matrix(data = c( 13.398438, 42.35122,
15.805148, 40.63947,
16.594402, 38.90598,
14.250850 ,40.83957,
11.341721, 44.49437,
13.768136, 45.64944,
12.483667, 41.89277,
8.932699, 44.41149,
9.190347, 45.46679,
13.518875, 43.61676,
14.659161, 41.55775,
11.356624, 46.49933,
11.121231, 46.06894,
7.680687, 45.07327,
16.867367, 41.12560,
9.110616, 39.21531,
13.362357, 38.11570,
11.255889, 43.76923,
12.388247, 43.10676,
7.320149, 45.73750,
12.338452, 45.43490), ncol = 2, byrow = T)
colnames(coord) <- c("lon", "lat")
rownames(coord) <- c("Abruzzo",
"Basilicata",
"Calabria",
"Campania",
"EmiliaRomagna",
"FriuliVeneziaGiulia",
"Lazio",
"Liguria",
"Lombardia" ,
"Marche",
"Molise",
"Bolzano",
"Trento",
"Piemonte",
"Puglia",
"Sardegna",
"Sicilia",
"Toscana",
"Umbria",
"ValledAosta",
"Veneto")
## plot regions with labels
par(mar = c(0,0,0,0))
plot(italy_red[c(1, 3, 5), ])
points(coord, pch = 20)
text(coord, pch = 20, labels = rownames(coord), font = 2)
plot(italy[c(1, 3, 5), ])
## plot regions with labels
par(mar = c(0,0,0,0))
plot(italy[c(1, 3, 5), ])
points(coord, pch = 20)
text(coord, pch = 20, labels = rownames(coord), font = 2)
cbind(5:28, c(143, 117, 99, 86, 76, 68, 62, 57, 52, 48, 45, 42, 40, 37, 36, 34, 32, 31, 29, 28, 27, 26, 25, 24))
coords <- cbind(5:26, c(143, 117, 99, 86, 76, 68, 62, 57, 52, 48, 45, 42, 40, 37, 36, 34, 32, 31, 29, 28, 27, 26)) - 1
coords
size(coords)
dim(coords)
nrow(coords)
coords[(nrow(coords)-1):1]
coords[(nrow(coords)-1):1, 2:1]
coords <- rbind(coords, coords[(nrow(coords)-1):1, 2:1])
coords
plot(coords)
plot(log(coords))
?lm
lm(log(coords[, 2]) ~ log(coords[, 1]))
lines(lm(log(coords[, 2]) ~ log(coords[, 1])))
?lines
coords <- cbind(5:26, c(143, 117, 99, 86, 76, 68, 62, 57, 52, 48, 45, 42, 40, 37, 36, 34, 32, 31, 29, 28, 27, 26)) - 1
coords <- rbind(coords, coords[(nrow(coords)-1):1, 2:1])
fit <- lm(log(coords[, 2]) ~ log(coords[, 1]))
fit$coefficients
plot(log(coords))
lines(c(0, 1), c(fit$coefficients[1], sum(fit$coefficients)))
range(log(coords[, 1]))
plot(log(coords))
lines(range(log(coords[, 1])), f(range(log(coords[, 1]))))
f <- function(x) fit$coefficients[1] + x * fit$coefficients[2]
plot(log(coords))
lines(range(log(coords[, 1])), f(range(log(coords[, 1]))))
plot(coords)
lines(range(coords[, 1]), exp(f(range(coords[, 1]))))
plot(coords)
lines(range(coords[, 1]), exp(f(range(log(coords[, 1])))))
range(coords[, 1])
seq(range(coords[, 1]))
f <- function(x) exp(fit$coefficients[1]) * x^fit$coefficients[2]
plot(coords)
grid <- min(coords[, 1]):max(coords[, 1])
lines(grid, f(grid))
fit$coefficients
grid
round(exp(6.4126819)*grid^-0.9994979)
floor(exp(6.4126819)*grid^-0.9994979)
load("C:/Users/Yulan/Google Drive/_RUG/2019-2020 MSc Mathematics Year 2/Master Research Project/paper/code/rdata/saved/empirical_full.RData")
setwd("~/GitHub/ZIBG-GLMM")
source('~/GitHub/ZIBG-GLMM/mcmcsample.R', echo=TRUE)
save(Q, propose, A, mcmcsample, rZIBG, file="rZIBG.rda")
source('~/GitHub/ZIBG-GLMM/generate.R', echo=TRUE)
plot(y)
source('~/GitHub/ZIBG-GLMM/generate.R', echo=TRUE)
source('~/GitHub/ZIBG-GLMM/constant_JAGS.R', echo=TRUE)
